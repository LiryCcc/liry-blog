# `react` `hooks` 讲

## 基础

### `useState` 在函数组件中添加局部状态

用来日俺家和管理状态，页面中插入的状态会随着状态的更新而更新

React 出于性能的考虑，会批量处理同一个事件处理函数里的多次 state 更新，并且如果是直接传值方式，后一次调用会覆盖前一次调用，因为它们都基于同一份旧状态做计算。

React 在一次事件中收集这个“批量更新”，最终取最后一次 setState 的值，所以两次结果都是 -1，最后就只会更新一次。

这就是为什么你觉得“只生效了一次”，实际上并不是失效，而是两次更新的结果是一样的，所以最终效果看起来像更新了一次。

但如果传入的是状态更新的函数，则会顺序执行两个更新函数，可以获得已更新但未提交到渲染的状态

```tsx
const App = () => {
  const [count, setCount] = useState(0);
  return (
    <div>
      <header>{'计数器'}</header>
      <button
        onClick={() => {
          setCount(count + 1);
        }}
      >
        {'+'}
      </button>
      <div>{`当前数字为: ${count}`}</div>
      <button
        onClick={() => {
          setCount(count - 1);
        }}
      >
        {'-'}
      </button>
    </div>
  );
};
```

### `useEffect` 处理副作用

纯渲染逻辑，也就是jsx是同步无副作用的，但是某些场景下需要执行副作用，就需要用useEffect管理副作用

1. 访问dom

2. eventListener

3. ajax/fetch

4. 定时器

5. 订阅

`useEffect`的依赖，依赖是副作用中用到的外部变量，当变量发生变化的时候会重新执行副作用，反之则不执行，如果不传参数，则每次渲染后都会执行副作用，
依赖列表用来控制副作用的执行时机，如果不传数组，则每次渲染都执行，如果传入空数组，则只会在首次渲染的时候执行，如果传入依赖列表，则只会在依赖列表中的变量发生变化时执行

原则：如果不是稳定的，则必须把副作用中用到的所有组件作用域内部的变量/函数都写入依赖列表

useEffect的旧值问题，如果依赖数组不包含这个变量，则永远读到的都是旧值，因为只有旧值被闭包捕获，但是新值没有，
如果需要让依赖稳定，则可以使用`useCallback`来稳定函数的引用，或者使用`useMemo`来稳定状态的引用，用`useRef`来稳定可变值的应用

`react`内部只是在每次渲染时，记住依赖数组的当前值，然后在下一次渲染时对比新旧依赖数组是否“相等”，使用的是`Object.is`，是浅比较，比较的是引用。

`useEffect`的副作用函数可以返回一个函数，用来请求副作用，比如取消订阅，移除`eventListener`，清除定时器，断开长连接

```tsx
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('hello world');
  }, 1000);
  return () => {
    clearTimeout(timer);
  };
}, []);
```

### `useContext` 订阅 `react context` ，避免 `props` 层层传递

## 额外的hook
